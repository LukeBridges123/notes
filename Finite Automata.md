# Finite Automata
A finite automaton is a certain kind of simple model of computation, characterized by having a strictly limited amount of memory. They come in two variants, deterministic and nondeterministic.

Deterministic Finite Automata
-----------------------------
Informally, a deterministic finite automaton (DFA) is a machine that either "accepts" or "rejects" strings of characters, which it processes by reading them character by character. It has memory in the form of a "state" (of which it has some finite number), and each time it reads in a character, it changes its state based on the character it just read and the state it's currently in. It can only be in one state at once, and only changes state by reading a character. It always starts in a specially designated "start" state. Once it has read all the characters, it "accepts" if the last character put it in a designated "accept" state, and "rejects" otherwise. DFAs can be modeled by directed graphs, where the vertices represent states and the edges (labeled with characters) represent transitions between states. When a DFA reads in a character (say "0"), its next state will be the one at the end of the arrow labeled with "0" which starts in its current state. The *language* of a DFA is the set of all strings which it accepts.

For example, a keypad might be an example of a DFA. It can be modeled as starting in a "0 characters correct so far" state, then reading in characters from user input one by one. If the first character it receives is the first character of the code, it will transition to a "1 character correct so far" state; otherwise, it will transition to an "incorrect" state, and all transitions from the incorrect state will just lead back to the incorrect state. If it ends up at, say, the "4 characters correct so far" state and receives no further input, it will accept. Its language consists only of the 4-digit code. (If it was instead modified so that, when in the "4 characters correct so far" state, all transitions from that state kept it in that state, its language would be all strings which start with the 4-digit code.)

More formally, a finite automaton has 5 parts: a finite set of states, Q; a finite set of symbols, ∑, called its "alphabet"; a function δ: Q x ∑ -> Q, called the "transition function", which maps each pair of a state and a character to another state; a start state q0 ∈ Q; and some set F ⊆ Q called the accept states. A finite automaton's computation can be defined as follows. Given some string w = w1w2...wn constructed by concatenating characters from the DFA's alphabet, the DFA accepts w if there is some sequence of states, q0q1...qn such that:

1. q<sub>0</sub> is the start state
2. q<sub>i+1</sub> =  δ(q<sub>i</sub>, w<sub>i+1</sub>) for all i >= 0
3. q<sub>n</sub> ∈ F

In other words, the DFA accepts w if there is a computation history which starts in the start state and ends in an accept state, and is valid in the sense that that the machine always moves between states according to what the transition function says to do, given the characters in w. 

A few minor points about DFAs cleared up be the formal definition: a DFA has only one start state, but can have none, some, or all of its states (including possibly the start state) be accept states. The transition function must map each state-symbol pair to another state (in the graph model, each node will have one edge leaving it for every symbol in the alphabet). Also, the transition function can leave the machine in the state it's currently in (more formally, we can have δ(q, w) = q); in the graph model, edges may be "loops" that lead directly from a state to itself. 

Example of a DFA in terms of its formal definition: here's a DFA that recognizes the language of strings made of 0s and 1s, which contain an even number of 1s. Its set of states will be Q = {even, odd}, its start state will be "even", its set of accept states will be {"even}, its alphabet will be {0, 1}, and its transition function δ will be as follows:
δ (even, 0) = even; δ (even, 1) = odd; δ (odd, 0) = odd; δ (odd, 1) = even.
In other words, this DFA keps track of whether the number of 1s it has seen is even or odd so far. Whenever it receieves a 1, it changes its state, and whenever it receives a 0, it keeps its state the same. Note that, because it starts in an accept state, the DFA accepts the empty string ε, since that string contains no 1s and thus has an even number of 1s in it.

Nondeterministic Finite Automata
--------------------------------
NFAs are a more complicated (but ultimately equivalent) version of DFAs. The "nondeterministic" in NFA means that, unlike in DFAs, where the transition function always maps a state-symbol pair to a single state, the transition function of an NFA maps to *sets of states*; thus an NFA's "next state" is not completely determined by its current state and most recent symbol. In a graph model of an NFA, each vertex could have one, many, or no edges leading out of it for a given symbol (the case where there are no edges corresponds to the transition function mapping that state-symbol pair to the empty set.) Also, an NFA can have "epsilon-moves" in its transition function; formally, these correspond to the transition function mapping a state and the empty string to a set of states, while informally, they can be interpreted in a number of different ways (as can nondeterminism in general).

One way of thinking of an NFA is as a DFA that can do parallel computation and be "in many states at once". The NFA starts in the start state plus the "epsilon-closure" of the start state--all the states that can be reached by following epsilon-moves from the start state, then from states that can be reached by following epsilon-moves from the start state, and so on. (Thus an NFA can "chain together" epsilon-moves and reach many states along the way, all without reading a symbol.) Then it reads in a symbol, computes the transition function for the symbol it read and each state it's currently in, puts itself in the union of all the sets of states returned by the transition function, then puts itself in the union of that and its epsilon-closure; then the process repeats itself until all the symbols have been read. The NFA accepts its input if, by the end, at least one of the states it's in is an accept state.

Another way of thinking of an NFA is as a DFA that is often able to "choose" among many possible transitions; its computation can be represented as a decision tree. In this model, at any given point, the NFA has the option of following one of the epsilon-transitions from its current state (if there are any) or reading in the next symbol; if it reads in the next symbol, it may have a further to make between the different states in the set to which the transition function maps that state-symbol pair. If a branch on the decision tree ever reaches a point where there are no epsilon-moves on the current state and the transition function maps the next symbol to the empty set, the branch "dies" and the NFA can proceed no further. The NFA accepts a string if some branch of the decision tree ends in an accept state--if, given the symbols in the string, there is some sequence of "choices" that lead the NFA to an accept state.

Formally, the main difference from DFAs is that, while the DFA's transition function maps state-symbol pairs to states, the NFA's maps pairs of a state and *either a symbol or the empty string* to (possibly empty) *sets of states*. An NFA's computation is similarly redefined: a string w is accepted by the NFA is accepted by the NFA if it can be rewritten as w<sub>1</sub>w<sub>2</sub>w<sub>3</sub>...w<sub>n</sub> where each w<sub>i</sub> is either a character in w or the empty string, and there is some sequence of states q0q1...qm such that: 

1. q<sub>0</sub> is the start state
2. q<sub>i+1</sub> ∈ δ(q<sub>i</sub>, w<sub>i+1</sub>) for all i >= 0
3. q<sub>m</sub> $\in$ F
This is similar to the definition of computation for a DFA, but with two differences. First, the definition of a valid "step" in a computation history is changed. Instead of it being "the ith state in the sequence is succeeded by the state to which the transition function maps (q<sub>i</sub>, w<sub>i+1</sub>)", it's "the ith state in the sequence is succeeded by *one of the states* in the *set of states* to which the transition function maps (q<sub>i</sub>, w<sub>i+1</sub>)". Epsilon-moves are dealt with using the idea that any string can be represented as either some characters concatenated together, or as those same characters concatenated together, but interspersed with empty strings which have been concatenated between the characters. An epsilon-move happens when, instead of reading in a character, the NFA "reads in the empty string" and takes one of the "branches" provided by the transition function.

Equivalence of DFAs and NFAs
--------------------------------
DFAs and NFAs are equivalent in the sense that, given any DFA, one can construct an NFA that recognizes the same language, and vice versa. (As a corollary, this means that a language is regular if and only if some NFA accepts it.) Converting a DFA into an equivalent NFA is easy: just think of the DFA's transition function as an NFA transition function that happens to only ever map state-symbol pairs to sets of single states. Converting an NFA to a DFA is easiest when thinking about an NFA as something that can "be in multiple states at once" and changes the set of states it's in upon reading a new symbol. The DFA will "simulate" the NFA by keeping track of the set of states that the NFA is in at each step, representing each set of states with a single state. Thus, given an NFA with a set of states Q, with |Q| = n, the equivalent DFA will have 2^n states, one for each subset of Q. The DFA's transition function will be defined as follows: if an NFA in some set of states has just read in the symbol w, then its new set of states consists of all the states reachable by following a single w-transition (i.e., in the graph model, an arrow from one state to another labeled with w) from one of its current states, plus all of the states reachable by following an epsilon-transition from one of those states, plus all of the states reachable by following a second epsilon-transition from one of *those* states, and so on. So it will end up in the set of states reachable by following a single w-transition from one of its current states, then following 0 or more epsilon-transitions from there. This gives a "purely deterministic" mapping from each set-of-states and symbol pair to another set-of-states, which the DFA can use as its transition function. In other words, when the DFA is in a state representing some set of states and reads in a symbol, its next state should represent the set of states reachable by following valid transitions on the NFA from one of the states in that set. Finally, the DFA's start state should be the set of states reachable by epsilon-arrows from the NFA's start state, and its accept states should be all the sets of states that, in the NFA, contain at least one accept state. 

In summary, an NFA's behavior can be completely captured by states representing sets of the NFA's states, and transitions that change the state to one representing the set of states that the NFA would be in if it followed all its valid transitions to the fullest. This means that, given an NFA, one can create a DFA that "simulates" it and accepts its language. This fact is used heavily in proving properties of the regular languages, as it allows one to work with NFAs rather than DFAs in order to construct things like an automaton that will accept the star of a regular language.

## Decidability of problems related to DFAs
### Acceptance testing
Most (all?) things that one might ask about a DFA turn out to be decidable. For instance, A<sub>DFA</sub>: given a pair of a DFA description {M} and an input string w, does M accept w? A TM can simulate a DFA by scanning through the input one symbol at a time, keeping track of the DFA's state all the while and deciding how to update it by scanning through the description of the transition function. Similarly, the problems of whether an NFA/regex accepts/generates a string are also decidable: run the algorithm to convert the NFA into a DFA, or the regex into an NFA (which is then converted to a DFA), then run the decider for A<sub>DFA</sub> on that. 
### Emptiness
More general problems about the language of a DFA are also decidable. For example, E<sub>DFA</sub>: does a DFA have an "empty" language, or does it accept at least some strings? The idea for deciding this is to search for paths along the DFA's transition-function graph leading from the start state to an accept state. Start out by marking the start state in the DFA's set of states, then mark all the states connected to some marked state (i.e. a state with some path back to the transition function) such that a single transition sends you from the marked state to the new state. Keep doing this until either (a) an accept state is marked or (b) the TM sweeps through the set of states and finds no new states to mark. In case (a), the TM has discovered some string which causes the DFA to accept, so the DFA's language is nonempty, so the TM rejects. In case (b), the TM has discovered all states connected to the start state and found that none of them are accepting states, so the DFA's language is empty. 
### Equivalence
The decidability of E<sub>DFA</sub>, combined with the closure of the regular languages under complement, union, and intersection, leads to the existence of a decider for EQ<sub>DFA</sub>, the language of pairs of DFAs that recognize the same language. It goes like this: given two DFAs M1 and M2 recognizing languages L1 and L2, first (using the general procedures for constructing complements, unions, and intersections of DFAs) construct a DFA that recognizes ((~L1 $\cap$ L2) U (L1 $\cap$ ~L2)): the set of all strings which are in L2 but not L1, or in L1 but not L2. Then test the resulting DFA for emptiness. If it's empty, then there are no strings recognized by one DFA but not the other, so they are equivalent; if not, they are not equivalent.