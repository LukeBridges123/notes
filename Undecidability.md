# Undecidability
A language is *undecidable* if no TM decides it. (Most common examples of such languages are either recognizable or co-recognizable but not both, although some like EQ<sub>TM</sub> are neither recognizable nor co-recognizable; see below for more.)

## Existence of undecidable languages
The existence of undecidable languages (although not any examples thereof) follows from a cardinality argument. Given an alphabet $\Sigma$, the set of all strings over that alphabet, $\Sigma *$, is countably infinite, as the strings can just be enumerated in the standard order (i.e. sort in order of length, then in lexicographic order within each length). Therefore, since any TM can be described with a finite string, the set of all TMs is countably infinite. However, the set of all languages over a certain alphabet is equal to P($\Sigma *$), and in general, the cardinality of a set is strictly less than that of its powerset. Therefore, there are uncountably infinite languages over a given alphabet. Thus, if we consider "Decides" as a function from TMs to languages, it cannot be a bijection, so there are languages (in fact, uncountably infinitely many languages) that no TM decides.

## A<sub>TM</sub>
A<sub>TM</sub> is the language consisting of all pairs of a TM description, {M}, and a string, w, such that M accepts w. It is recognizable, due to the existence of a "universal Turing machine" which, given a TM description and an input, simulates that TM on that input, and accepts or rejects based on whether the simulated TM accepts or rejects. (If its input is a TM description and a string that that TM accepts, then the universal machine will also accept, hence why the langugage is recognizable.) However, A<sub>TM</sub> is not decidable; the proof is by contradiction. Suppose that there were a machine A which decided A<sub>TM</sub>. Then we could construct a new machine, D, which works as follows: on receiving a TM description {M}, it calls A on input {M, {M}}, i.e. has A investigate whether M halts when run on M's description. It then rejects its input if A accepted, and accepts if A rejected. 

Taken at face value, nothing seems paradoxical--D is just a machine that decides the language "descriptions of TMs which do not accept their own description". However, what happens when D is given its own description as input? If it accepts its own description, then A will accept on input {D, {D}}, but that means that D will reject its own description. If it rejects its own description, then A will reject on input {D, {D}}, but that means that D will accept its own description. So D accepts its own description iff it rejects its own description-- a contradiction. Since the construction of D from A was valid, the problem must lie in the assumption that A exists. So A must not exist--no TM decides A<sub>TM</sub>. As a corollary, since A<sub>TM</sub> is recognizable but not decidable, its complement must not be recognizable. 

### Diagonalization in the proof of the undecidability of A<sub>TM</sub>
The proof above is really a proof by diagonalization. Consider laying out all TMs in an infinite row, and then having their corresponding descriptions, in the same order, an an infinite column (which is doable, as there are countably many TMs); each cell in the resulting grid is labeled "accept" or "reject" based on whether the TM in that column accepts or fails to accept the TM description on that row. For example, if the cell (2, 1) is labeled "accept", then the 2nd TM accepts the description of the 1st TM. The diagonal entries in this grid show whether each TM accepts its own description. D's column is the opposite of the diagonal entries: for example, if (1, 1) is "accept", then the cell at the intersection of D's column and the 1st row is "reject", since D rejects the first TM's description. But what happens at the intersection of D's column and the row with D's description? That's also a diagonal entry, but the entries in D's column are the opposite of the diagonal entries, so that entry is the opposite of itself--a contradiction.

This "diagonalization" strategy of creating a TM which shows paradoxical behavior when run on its own description shows up in many places in computability and complexity theory; list to be filled in later.

## Other Undecidable Problems about Turing Machines
### Halting Problem
The problem of determining whether a TM M halts on input w can be proven undecidable either directly (using a similar strategy to the proof for A<sub>TM</sub>) or by reduction to A<sub>TM</sub>. For the reduction proof: supposing a TM H decided the halting problem, to decide A_TM, feed H the input (M, w). If H accepts, then M certainly doesn't accept w, so reject. If H rejects, simulate M and w to see whether it accepts or rejects (and it must, given that it halts) and accept or reject based on that.  
### Emptiness
It is undecidable whether a TM's language is empty, i.e. it accepts no strings. The proof involves a common trick: take a TM M and input w and "package" them into a "single-purpose" TM, M', whose only function is to simulate M on input w; then, deciding certain properties of M' would give you the ability to determine whether M accepts w. For example, say some TM E decided whether other TMs had empty languages. Then let M' be a machine which, on any input, ignores the input and begins simulating M on input w, accepting iff M accepts w. If M does not accept w, then M' will not accept any string, i.e. will have an empty language, while if M accepts w, then M' will have a nonempty language. So the decider for emptiness would let you decide acceptance; but since acceptance is undecidable, no such emptiness tester must exist.
### Equivalence (fix later)
A similar trick proves that the problem of testing whether two TMs accept the same language is neither recognizable nor co-recognizable (i.e. neither it nor its complement is recognizable). If you could recognize equivalence, then you could take the same TM M' from above and decide whether its language is empty by testing equivalence with a "trivial" TM that immediately rejects all strings. If you could recognize non-equivalence, then you could also decide emptiness by testing whether M' is not equivalent to a different "trivial" TM that immediately accepts all strings (since M' either accepts all inputs (in the case where M accepts w) or rejects all inputs (in the case where M doesn't accept w), if it doesn't accept all strings, it must have an empty language). So equivalence is "even more undecidable" than, say, emptiness, because at least with emptiness one can recognize TMs with nonempty languages, whereas with equivalence, one cannot, in general, recognize pairs of equivalent TMs or pairs of nonequivalent TMs. 
### Rice's Theorem
  
## Undecidable Problems about Other Automata and Language Classes

### Emptiness of LBAs
Say that a linear bounded automaton is a TM with a finite tape just large enough to contain its input. (Technical note: this really means that the LBA is restricted to an amount of space linear in the size of the input, not just that it is restricted to an amount of space equal to the size of the input (i.e. if the input is n cells long, then the LBA, in a certain sense, doesn't just have access to n cells-- it can have symbols in its tape alphabet that encode, say, triplets of cells, and rewrite an input "aba" to "(blank-blank-a)(blank-blank-b)(blank-blank-a)", thus gaining 6 "extra" cells to work with. The problems decidable by TMs but not LBAs are precisely those which always take more than O(n) space. But this isn't directly relevant to the following proof.)

Testing whether an LBA accepts its input is decidable, unlike in the case of TMs. This is because an LBA has a finite number of configurations it can be in on a given input (namely, an LBA with $q$ states, $s$ symbols in its alphabet, and $n$ tape cells can be in $qsn$ distinct configurations). So one can just simulate an LBA, accept if it accepts, rejects if it rejects, and reject if it goes on for more than $qsn$ time steps (because this means that it has repeated a configuration and thus will loop infinitely).

However, testing whether an LBA's language is empty is undecidable. This is because, while LBAs clearly cannot simulate arbitrary TMs, they can check whether a computation history for a TM is valid and ends in acceptance. In particular, given some TM M and input w, one can create an LBA which will only accept valid accepting computation histories for M on input w. That LBA's language is thus empty if and only if M does not accept w, so deciding whether an LBA is empty would allow you to decide whether M accepts w.



### Equivalence of CFGs 

## Undecidable Problems Not Directly Related to Automata

### Post Correspondence Problem
