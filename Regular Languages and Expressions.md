# Regular Languages and Expressions
The *regular languages* are the languages (i.e. sets of strings) which are accepted by some DFA (or, equivalently, some NFA). They are to some extent "robust" in the sense that they are closed under several common operations, i.e. the result of applying one of those operations to regular language(s) is also a regular language. Regular languages turn out to be equivalent to the languages generated by regular expressions, which are a certain way of describing languages in terms of unions, concatenations, and stars (see below) of single characters and other regular expressions. This means that, given a DFA, one can construct a regular expression describing the language it accepts, and given a regex, one can construct a DFA accepting its language. 

## Closure of the Regular Languages Under Regular Operations
The "regular operations" on languages are the union U, concatenation o, and star \*. They are defined as follows (note that, in the examples below, A = {12, 34} and B = {ab, cd}):
### The Regular Operations
The union of two languages is just that, the set consisting of all the strings in the first language and all the strings in the second. E.g., A U B = {x|x is in A or is in B} = {12, 34, ab, cd}. 
The concatenation of two languages is the set consisting of all the strings created by putting a string from the second language onto a string from the first. So A o B = {xy| x is in A and y is in B} =  {12ab, 12cd, 34ab, 34cd}. 
The star of a single language is all the strings formed by concatenating 0 or more strings from the language. (Since it's "0 or more", the star of a language always includes $\epsilon$, the empty string.) So A\* = {x1, x2, ... xk| k >= 0 and each xi is in A} =  {$\epsilon$, 12, 34, 1212, 1234, 3412, 3434, 121212, 121234, 123412, ...}

Note that these operations are defined at the level of *languages*, not individual strings. So the concatenation of two languages is *all possible* concatenations of strings from the first language and second language, not just two specific strings concatenated together.

The regular languages are closed under the regular operations, meaning that the union or concatenation of two regular languages is also regular, as is the star of a regular language. Proof:
### Union (and intersection)
For the union of regular languages: this can be proven in two ways, one involving only DFAs and one involving NFAs. 
First, given two regular languages A and B, there must be a DFA M accepting A and a DFA N accepting B. It's possible to create a DFA that "simulates" both of them at once, by having states that represent ordered pairs of states from A and states from B (in other words, the new DFA's set of states is the Cartesian product of A's set of states and B's set of states). So, for example, if Sm is M's start state and Sn is N's start state, then the new DFA's start state will be (Sm, Sn). Transitions are handled like this: say that the DFAs have transition functions $\delta$m and $\delta$n respectively; then the new transition function $\delta$ will be $\delta$((qm, qn)) = ($\delta$m(qm), $\delta$n(qn)). The accept states are all the pairs of states where at least one is an accept state. (Switching this to all the pairs of states where both are accept states leads to a DFA that recognizes the intersection of the two languages; thus the regular languages are closed under intersection.)

An alternate proof involves NFAs. Given two NFAs M and N recognizing the two languages, construct a new NFA that "contains" both of them. It has all of their states (renamed as needed to avoid "name collisions") plus a new start variable, S0, with epsilon-transitions leading to the start states of M and N. The transition function is just the union of M and N's transition functions (i.e. contains all the ordered pairs from each function). The upshot of all this is that, at the start, the NFA splits into two main branches, one that simulates the computation of M and one that simulates the computation of N. Then those branches compute independently, and the NFA as a whole accepts iff one of them accepts. 

A brief note on how FAs over different alphabets should be handled: the proofs here assume that both the languages are in the same alphabet. However, the NFA accepting the union of two regular languages needs to have its alphabet be the union of the two original NFAs' alphabets, so that it can recognize strings from both languages. In the case where one of the "simulated" NFAs encounters a symbol not in its alphabet (and thus not in its language), it should reject that string; one way to do this is to simply have that NFA "crash", by adding terms to its transition function mapping a state from M and a symbol not in M's original alphabet to the empty set. This leads to that branch of computation "dying".
### Concatenation
Closure under concatenation: given NFAs M and N recognizing languages A and B, create a new NFA consisting of N "glued" to the end of M. More formally, the start state should be the start state of M, and all the accept states of M should no longer be accept states; instead, they should have epsilon-transitions leading to the start state of B. This means that, if a string consists of a string from A followed by a string from B, then when the NFA processes it, it will first end up in one of M's accept states (when the portion from A ends), then jump over to N's start state, then end up in one of N's accept states (since the remaining part of the string is from B), and thus accept the string as a whole. This can also be viewed as allowing the machine to "guess" at what point the two strings were joined. 
### Star
Closure under star: given an NFA M accepting language A, need to accept all the strings consisting of 0 or more strings from A concatenated together. This means that the empty string must be accepted; this can be handled by adding a new start state which is also an accept state, and giving it an epsilon-transition leading back to the original start state of M. Keep the set of accept states as M's accept states, but add epsilon-transitions leading from each of the accept states back to M's old start state. This means that once part of the string is found to belong to A, the NFA goes back to the start to see if the rest of the string also consists of strings from A. 
### Closure under other operations
The regular languages are closed under complementation: given a DFA M which accepts the language A, a DFA accepting the complement of A can be constructed by creating a DFA identical to M, accept that its accept states are all and only the states which were not accept states in M. Thus the new DFA accepts a string iff M does not. 

## Regular Expressions and their Equivalence with NFAs


### Every regular expression generates a regular language

### Every regular language is described by a regular expression

## Conditions for Nonregularity of a Language
### Pumping Lemma

### Myhill-Nerode Theorem


