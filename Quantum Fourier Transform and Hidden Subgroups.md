Most (all?) known problems where quantum computers appear to have an exponential advantage over classical ones can be described as instances of the "Abelian hidden subgroup problem", which can be solved using the quantum Fourier transform. We begin with some simple examples of oracle problems where a quantum computer has a significant advantage over a classical one; only much later will we fit these into the framework of the hidden subgroup problem. 

# Some Oracle Problems
## Deutsch's Algorithm
Consider the following simple problem. Suppose we have some unknown function $f$, accessible only by a black box or oracle, which takes in a bit and outputs a bit. To know whether $f(0) = f(1)$ or not--in other words, to know the value of $f(0) \oplus f(1)$-- it seems like you need to make 2 oracle queries: if you only know $f(0)$ or $f(1)$ alone, how could that be useful? With a quantum computer, however, only one query is needed, although "query" admittedly means something a bit different here. 

First we note how the oracle for $f$ should work in a quantum context. Due to reversibility we cannot simply have it be a 1-qubit gate defined by $\ket{x} \to \ket{f(x)}$, nor can it be a 2-qubit gate like $\ket{xy} \to \ket{xf(x)}$. Instead we implement the oracle $U_f$ by the rule $\ket{x}\ket{y} \to \ket{x}\ket{y \oplus f(x)}$. (This is reversible since you no longer have the problem where any $y$ gets overwritten by $f(x)$ and so you can't work backwards from $f(x)$ to $y$--rather $y$ gets overwritten by $f(x)$ or not-$f(x)$ depending on the value of $y$, so you can work backwards.) In fact, extending this action on the basis states to a linear map, we get a unitary operator, so this is a valid gate for our qubits, regardless of what $f$ is. 

Now we describe the algorithm itself.
1. Start out with the 2-qubit state $\ket{01}$. 
2. Apply a Hadamard gate to both qubits. You end up with $(\frac{\ket{0} + \ket{1}}{\sqrt{2}})(\frac{\ket{0} - \ket{1}}{\sqrt{2}})$. 
3. Pass this whole thing through $U_f$, the oracle for $f$. What happens then? Instead of expanding the state in (2) fully and working with that directly, think about what happens when applying $f$ to $\ket{x}\frac{\ket{0} - \ket{1}}{\sqrt{2}}$. You get $\ket{x}\frac{\ket{f(x)} - \ket{\neg f(x)}}{\sqrt{2}}$; when $f(x) = 0$ the second qubit is $\frac{\ket{0} - \ket{1}}{\sqrt{2}}$, so the system as a whole is unchanged, while when $f(x) = 1$ the second qubit is $\frac{\ket{1} - \ket{0}}{\sqrt{2}}$, which is the original state multiplied by $-1$. Thus the oracle sends $\ket{x}\frac{\ket{0} - \ket{1}}{\sqrt{2}}$ to $(-1)^{f(x)}\ket{x}\frac{\ket{0} - \ket{1}}{\sqrt{2}}$. 
4. Thus when $f(0) = f(0) = 0$, the first qubit $\frac{\ket{0} + \ket{1}}{\sqrt{2}}$ gets sent to $\frac{\ket{0} + \ket{1}}{\sqrt{2}}$; when $f(0) = f(1) = 1$, it gets sent to $-(\frac{\ket{0} + \ket{1}}{\sqrt{2}})$; when $f(0) = 0, f(1) = 1$ it gets sent to $\frac{\ket{0} - \ket{1}}{\sqrt{2}}$; and when $f(0) = 1, f(1) = 0$ it gets sent to $\frac{-\ket{0} + \ket{1}}{\sqrt{2}} = -(\frac{\ket{0} - \ket{1}}{\sqrt{2}})$. So the overall state will be (up to an unimportant global phase of $1$ or $-1$) either $(\frac{\ket{0} + \ket{1}}{\sqrt{2}})(\frac{\ket{0} - \ket{1}}{\sqrt{2}})$, when $f(0) = f(1)$, or $(\frac{\ket{0} - \ket{1}}{\sqrt{2}})(\frac{\ket{0} + \ket{1}}{\sqrt{2}})$ otherwise. 
5. Thus the first qubit is $\ket{+}$ or $\ket{-}$ depending on whether $f(0) = f(1)$; all we have to do then is measure in the $\ket{+}, \ket{-}$ basis. Or, if you prefer, we apply a Hadamard gate to the first qubit, are left with $\ket{0}$ if $f(0) = f(1)$ and $\ket{1}$ otherwise, i.e. left with $\ket{f(0) \oplus f(1)}$ as the first qubit, so we can just measure the first qubit in the computational basis. 
Here's another way of thinking about what's going on here. $\ket{x}\ket{-}$, where $\ket{x}$ is an element of the computational basis, is an eigenvector of $U_f$ with eigenvalue $(-1)^{f(x)}$; what we do is pass a superposition of two of these eigenvectors through $U_f$. While we might think about $U_f$ as acting only on the $\ket{-}$ part and leaving the $\ket{x}$ at the start unchanged, this extra factor of $(-1)^{f(x)}$ propagates up to the first qubit. Together, the $(-1)^{f(0)}$ and $(-1)^{f(1)}$ leave the relative phase of the first qubit unchanged or changed depending on whether $f(0) = f(1)$ or not; this then determines what happens when we measure it in the $\ket{+}, \ket{-}$ basis. 
## Deutsch-Jozsa Algorithm
A generalization of the above algorithm can deal with another toy problem. Let $f$ be a function on bit-strings of length $n$, which is either "constant" (i.e. $0$ for all inputs or $1$ for all inputs) or "balanced" ($0$ for half of possible inputs and $1$ for the other half). A classical deterministic algorithm needs at least $2^{n-1} + 1$ queries to decide whether $f$ is constant or balanced: for, regardless of whether it's constant or balanced, it's possible to get all zeros and all ones on your first $2^{n-1}$ queries, which would be consistent with either a constant or balanced function, and then another query is both necessary and sufficient to decide. A classical probabilistic algorithm can work quickly, though. For, say we choose $k$ values at random and apply $f$ to them; if we get at least one 0 and at least one 1 then return "balanced", else return "constant". If $f$ is constant this will always work; if it's balanced, then it'll go wrong with probability $\frac{1}{2^{k-1}}$ (since the probability that we get $k$ zeros is $\frac{1}{2^k}$, and the same for $k$ ones). Thus we can solve it with as small a probability as we want using only O(1) queries. With a quantum algorithm, however, it is possible to solve it with certainty while making only one query. 

Here the oracle takes in a qubit $\ket{x, y}$ where $x$ is a length-n bit string and returns $\ket{x, y \oplus f(x)}$. With this in mind, the algorithm works as follows:
1) Start in the state $\ket{0}^{\otimes n}\ket{1}$, i.e. a string of $n$ zeros followed by a 1. 
2) Apply a Hadamard transform (i.e. one Hadamard gate per qubit) to the first $n$ bits, as well as a Hadamard gate to the last qubit. Now everything is in the state $\sum_x \frac{\ket{x}}{\sqrt{2^n}} \frac{\ket{0} - \ket{1}}{\sqrt{2}}$ where the sum is taken over all length-$n$ bit strings. 
3) Pass everything through the oracle $U_f$. Similar to how it works in Deutsch's algorithm, this leaves everything in the state $\sum_x \frac{(-1)^{f(x)}\ket{x}}{\sqrt{2^n}} [ \frac{\ket{0} - \ket{1}}{\sqrt{2}}]$. 
4) Now we do another Hadamard transform on the first $n$ qubits. To describe the result it will first be useful to redescribe the result of applying a Hadamard to a single qubit $\ket{x}$: omitting the normalization for now you get $\ket{0} + \ket{1}$ for $x = 0$ or $\ket{0} - \ket{1}$ for $x = 0$; in other words $(-1)^{x\cdot 0}\ket{0} + (-1)^{x\cdot 1} \ket{1}$, or $\sum_z (-1)^{xz}\ket{z}$. When you have a 2-qubit string $\ket{x_1x_2}$, this gets turned into $[\sum_{z_1} (-1)^{x_1z_1}\ket{z_1}][\sum_{z_2} (-1)^{x_2z_2}\ket{z_2}]$ which distributes out to $\sum_{z_1, z_2} (-1)^{x_1z_1 + x_2z_2} \ket{z_1z_2}$ . Generalizing this, an $n$-qubit string $\ket{x_1\dots x_n}$ becomes $\sum_{z_1, \dots, z_n}(-1)^{x_1z_1 + \dots + x_nz_n}\ket{z_1\dots z_n}$. Observe that the exponent on $-1$ is the dot product of the vectors $(x_1, \dots, x_n)$ and $(z_1, \dots, z_n)$ Thus $\sum_x \frac{(-1)^{f(x)}\ket{x}}{\sqrt{2^n}} [ \frac{\ket{0} - \ket{1}}{\sqrt{2}}]$ gets sent to $$\sum_z \sum_x \frac{(-1)^{x \cdot z + f(x)}\ket{z}}{2^n}[\frac{\ket{0} - \ket{1}}{\sqrt{2}}]$$ where the outer and inner sums are both taken over all length-$n$ bit strings; note that we've interchanged the order of summation from what you would expect. 
5) Now consider the amplitude on $\ket{0}^{\otimes n}$, which is $\frac{1}{2^n}\sum_x (-1)^{x \cdot (0, \dots, 0) + f(x)} = \frac{1}{2^n}\sum_x (-1)^{f(x)}$ . If $f(x) = 0$ for all $x$ then this is equal to $\frac{2^n}{2^n} = 1$, and if $f(x) = 1$ for all $x$ this is equal to $-1$. In either case all the amplitudes on the other basis states must be $0$, else the state vector would have norm greater than $1$. Thus if $f$ is constant we will measure all zeros. On the other hand if $f$ is balanced, the terms of the sum will consist of $n$ copies of $1$ and $n$ copies of $-1$, and so the amplitude of the all-zero string will be $0$. Thus we will be guaranteed to measure a string that is not all zeroes, and so we can determine with certainty whether $f$ is constant or balanced by measuring the first $n$ qubits and seeing if we get all zeros or something else. 
