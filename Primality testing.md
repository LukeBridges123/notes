## Exponential-Time Algorithms
### Trial division
The most basic form of trial division is to divide some number n by every number below n. If one can evenly divide it by any other number, n must be composite; if, after checking all numbers below n, none evenly divide n, n must be prime. This can be optimized somewhat; in particular, it is only necessary to check all numbers up to and including the square root of n. If n has no factors less than or equal to its square root, it must have no factors greater than its square root, and so must be prime. In this case, if we let d be the number of bits in n's binary representation, we can loosely approximate n as $2^d$, which means that this kind of trial division will take rougly $2^{d/2}$ steps to determine primality--in other words, it is an exponential time algorithm.

### Converse of Wilson’s Theorem
Recall that Wilson’s Theorem states that, for any prime p, (p-1)! is congruent to -1 (mod p). Its converse, that if (n-1)! is congruent to -1 (mod n), n must be prime, is also true. So one could test primality by calculating (n-1)! (mod n). However, there is no quick way to do this, especially given that (n-1)! gets huge quickly as n increases, so Wilson’s Theorem is not practical as a primality test. To be a bit more specific, we can again use d to represent the number of bits in n's binary representation; since n is roughly equal to 2^d^, and we have to perform n-1 multiplications, primality testing with Wilson's Theorem will need about 2^d^ steps to complete. This means that, like trial division, it is an exponential time algorithm, and is essentially always worse than trial divison; the fact that multiplication is generally faster than division is swamped by having to perform $2^d$ of the multiplications as opposed to just $2^{d/2}$ division / mod operations.

## Probabilistic Algorithms

### Fermat's Little Theorem as a Primality Test
Fermat's little theorem states that, if p is prime and a is relatively prime to p, then $a^{p-1} \equiv 1$ (mod p); its contrapositive is that, if $a^{p-1} \neq 1$ (mod p), then p is composite or a is not relatively prime to p. Thus given some n to test for primality, one can choose an arbitrary a relatively prime to n, compute $a^{n-1}$ mod n (which can be done in polynomial time using the "repeated squaring" algorithm), and   if the result is not 1, n is definitely composite. However, the converse of Fermat's Little Theorem is false: if $a^{n-1} = 1$ (mod n), then n is not necessarily prime. In fact, there exist "Carmichael numbers" or "Fermat pseudoprimes" such that $a^{n-1} = 1$ (mod n) for all coprime a; the first example is 561 (3 x 11 x 17); for that matter, even composite numbers which are not Carmichael can fulfill $a^{n-1} = 1$ (mod n) for some (though not all) coprime a. These are rare enough that the Fermat test works reasonably well in practice, although deriving precise bounds on the number of Carmichael numbers is difficult and thus the Fermat test cannot rigourously be placed in a complexity class like BPP. However, this is irrelevant since other tests like the Miller-Rabin test are both better in practice and easier to analyze practically. 
### Miller-Rabin Test 

